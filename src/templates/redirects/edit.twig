{% extends "_layouts/cp" %}
{% import "_includes/forms" as forms %}

{% set plugin = craft.app.plugins.getPlugin('redirect-manager') %}
{% set pluginName = plugin.settings.pluginName %}
{% set singularName = pluginName matches '/s$/' ? pluginName|slice(0, -1) : pluginName %}

{% set title = isNew ? 'New {singularName}'|t('redirect-manager', {singularName: singularName}) : 'Edit {singularName}'|t('redirect-manager', {singularName: singularName}) %}
{% set selectedSubnavItem = 'redirects' %}

{% set crumbs = [
    { label: pluginName, url: url('redirect-manager') },
    { label: pluginName, url: url('redirect-manager/redirects') },
    { label: isNew ? 'New {singularName}'|t('redirect-manager', {singularName: singularName}) : redirect.sourceUrl }
] %}

{% set fullPageForm = true %}
{% set saveShortcutRedirect = redirect ? 'redirect-manager/redirects/' ~ redirect.id : 'redirect-manager/redirects' %}

{% block content %}
	{{ actionInput('redirect-manager/redirects/save') }}
	{{ redirectInput('redirect-manager/redirects') }}

	{% if not isNew %}
		{{ hiddenInput('redirectId', redirect.id) }}
	{% endif %}

	<div class="field" style="margin-top: 0px;">
		<div class="heading">
			<label for="redirectSrcMatch">{{ 'Source Match Mode'|t('redirect-manager') }}
				<span class="required" aria-label="Required"></span>
			</label>
			<div class="instructions">
				{% set srcMatchValue = redirect ? redirect.redirectSrcMatch : (craft.app.request.getParam('redirectSrcMatch') ?: craft.redirectManager.settings.redirectSrcMatch) %}
				<p id="srcMatchInstructions">
					{% if srcMatchValue == 'fullurl' %}
						{{ 'Match by complete URL including domain (e.g., https://example.com/old-page).'|t('redirect-manager') }}
					{% else %}
						{{ 'Match by path only (e.g., /old-page). Works across all domains.'|t('redirect-manager') }}
					{% endif %}
				</p>
			</div>
		</div>
		<div class="input">
			<div class="select">
				<select id="redirectSrcMatch" name="redirectSrcMatch" required>
					<option value="pathonly" {% if srcMatchValue == 'pathonly' %} selected {% endif %}>{{ 'Path Only'|t('redirect-manager') }}</option>
					<option value="fullurl" {% if srcMatchValue == 'fullurl' %} selected {% endif %}>{{ 'Full URL'|t('redirect-manager') }}</option>
				</select>
			</div>
		</div>
		<p id="pathOnlyTip" class="notice has-icon" style="display: {{ srcMatchValue == 'pathonly' ? 'block' : 'none' }}; margin-top: 10px;">
			<span class="icon" aria-hidden="true"></span>
			<span class="visually-hidden">Tip:
			</span>
			<span>Full URLs entered will be automatically converted to paths when saving.</span>
		</p>
	</div>

	{{ forms.selectField({
        label: 'Match Type'|t('redirect-manager'),
        instructions: 'How the source URL should be matched'|t('redirect-manager'),
        id: 'matchType',
        name: 'matchType',
        value: redirect ? redirect.matchType : 'exact',
        options: matchTypes,
        required: true
    }) }}

	<div class="field" id="sourceUrl-field">
		<div class="heading">
			<label for="sourceUrl">{{ 'Source URL'|t('redirect-manager') }}
				<span class="required" aria-label="Required"></span>
			</label>
			<div class="instructions">
				<p id="sourceUrlInstructions">
					{% if srcMatchValue == 'fullurl' %}
						{{ 'Enter the full URL to match (e.g., https://example.com/old-page).'|t('redirect-manager') }}
					{% else %}
						{{ 'Enter the path to match (e.g., /old-page). Full URLs will be automatically converted to paths.'|t('redirect-manager') }}
					{% endif %}
				</p>
			</div>
		</div>
		<div class="input ltr">
			<input type="text" id="sourceUrl" name="sourceUrl" value="{{ redirect ? redirect.sourceUrl : craft.app.request.getParam('sourceUrl') }}" placeholder="{{ srcMatchValue == 'fullurl' ? 'https://example.com/old-page' : '/old-page' }}" required class="text fullwidth">
		</div>
		{% if redirect and redirect.getErrors('sourceUrl') %}
			<ul class="errors">
				{% for error in redirect.getErrors('sourceUrl') %}
					<li>{{ error }}</li>
				{% endfor %}
			</ul>
		{% endif %}
		<p id="regexTip" class="notice has-icon" style="display: none; margin-top: 10px;">
			<span class="icon" aria-hidden="true"></span>
			<span class="visually-hidden">Tip:
			</span>
			<span>Test your pattern at
				<a class="go" href="https://regexr.com/" target="_blank" rel="noopener">regexr.com</a>
				before saving.</span>
		</p>
	</div>

	{{ forms.textField({
        label: 'Destination URL'|t('redirect-manager'),
        instructions: 'Full URL (https://example.com) or path (/page)'|t('redirect-manager'),
        id: 'destinationUrl',
        name: 'destinationUrl',
        value: redirect ? redirect.destinationUrl : null,
        placeholder: '/page or https://example.com',
        required: true,
        errors: redirect ? redirect.getErrors('destinationUrl') : null
    }) }}

	<hr>

	<div id="priority-field" style="display: {{ (redirect ? redirect.matchType : 'exact') == 'exact' ? 'none' : 'block' }};">
		<div class="field">
			<div class="heading">
				<label for="priority">{{ 'Priority'|t('redirect-manager') }}</label>
				<div class="instructions">
					<p>{{ 'Redirects are checked in priority order (0 = highest priority, 9 = lowest). Use this when you have overlapping patterns. For example, set a specific pattern to priority 0 and a general catch-all to priority 9.'|t('redirect-manager') }}</p>
				</div>
			</div>
			<div class="input ltr">
				<div class="select">
					<select id="priority" name="priority" style="width: 250px;">
						{% for i in 0..9 %}
							<option value="{{ i }}" {% if (redirect ? redirect.priority : 0) == i %} selected {% endif %}>
								{{ i }}
								-
								{{ i == 0 ? 'Highest priority' : (i == 9 ? 'Lowest priority' : 'Priority ' ~ i) }}
							</option>
						{% endfor %}
					</select>
				</div>
			</div>
		</div>

		<hr>
	</div>

	<div class="field">
		<div class="heading">
			<label for="statusCode">{{ 'Status Code'|t('redirect-manager') }}
				<span class="required" aria-label="Required"></span>
			</label>
			<div class="instructions">
				<p>{{ 'The HTTP status code to use for the redirect'|t('redirect-manager') }}</p>
			</div>
		</div>
		<div class="input">
			<div class="select">
				<select id="statusCode" name="statusCode" required>
					{% for code, label in statusCodes %}
						<option value="{{ code }}" {% if (redirect ? redirect.statusCode : 301) == code %} selected {% endif %}>{{ label }}</option>
					{% endfor %}
				</select>
			</div>
		</div>
		<p id="statusCodeTip" class="notice has-icon" style="margin-top: 10px;">
			<span class="icon" aria-hidden="true"></span>
			<span class="visually-hidden">Tip:
			</span>
			<span id="statusCodeTipText">Most common: Use
				<strong>301</strong>
				for permanent moves.
				<a class="go" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" target="_blank" rel="noopener">Learn more about HTTP status codes</a>
			</span>
		</p>
	</div>

	{% include 'redirect-manager/_components/plugin-credit.twig' %}
{% endblock %}

{% block details %}
	<fieldset>
		<legend class="h6">{{ 'Status'|t('redirect-manager') }}</legend>
		<div class="meta">
			{{ forms.lightswitchField({
                label: 'Enabled'|t('redirect-manager'),
                id: 'enabled',
                name: 'enabled',
                on: redirect ? redirect.enabled : true
            }) }}
		</div>
	</fieldset>

	{% if craft.app.getIsMultiSite() %}
		<fieldset>
			<legend class="h6">{{ 'Site'|t('redirect-manager') }}</legend>
			<div class="meta">
				{{ forms.selectField({
                    label: 'Site'|t('redirect-manager'),
                    instructions: 'Select which site this redirect applies to'|t('redirect-manager'),
                    id: 'siteId',
                    name: 'siteId',
                    value: redirect ? redirect.siteId : craft.app.request.getParam('siteId'),
                    options: [{ label: 'All Sites'|t('redirect-manager'), value: '' }]|merge(craft.app.sites.getAllSites()|map(site => { label: site.name, value: site.id }))
                }) }}
			</div>
		</fieldset>
	{% endif %}

	{% if not isNew %}
		<fieldset>
			<legend class="h6">{{ 'Statistics'|t('redirect-manager') }}</legend>
			<dl class="meta read-only">
				<div class="data">
					<dt class="heading">{{ 'Hit count'|t('redirect-manager') }}</dt>
					<dd class="value">{{ redirect.hitCount }}</dd>
				</div>
				{% if redirect.lastHit %}
					<div class="data">
						<dt class="heading">{{ 'Last hit'|t('redirect-manager') }}</dt>
						<dd class="value">{{ redirect.lastHit|datetime('short') }}</dd>
					</div>
				{% endif %}
				<div class="data">
					<dt class="heading">{{ 'Created'|t('redirect-manager') }}</dt>
					<dd class="value">{{ redirect.dateCreated|datetime('short') }}</dd>
				</div>
				<div class="data">
					<dt class="heading">{{ 'Updated'|t('redirect-manager') }}</dt>
					<dd class="value">{{ redirect.dateUpdated|datetime('short') }}</dd>
				</div>
			</dl>
		</fieldset>
	{% endif %}
{% endblock %}

{% js %}
    // Simple form behavior - show/hide fields, server handles validation
    const matchTypeSelect = document.getElementById('matchType');
    const priorityField = document.getElementById('priority-field');
    const regexTip = document.getElementById('regexTip');
    const statusCodeSelect = document.getElementById('statusCode');
    const statusCodeTipText = document.getElementById('statusCodeTipText');
    const redirectSrcMatchSelect = document.getElementById('redirectSrcMatch');
    const pathOnlyTip = document.getElementById('pathOnlyTip');
    const sourceUrlInput = document.getElementById('sourceUrl');
    const sourceUrlInstructions = document.getElementById('sourceUrlInstructions');
    const srcMatchInstructions = document.getElementById('srcMatchInstructions');

    // Show/hide priority field based on match type
    if (matchTypeSelect && priorityField) {
        matchTypeSelect.addEventListener('change', function() {
            priorityField.style.display = this.value === 'exact' ? 'none' : 'block';
        });
    }

    // Show/hide regex tip
    if (matchTypeSelect && regexTip) {
        matchTypeSelect.addEventListener('change', function() {
            regexTip.style.display = this.value === 'regex' ? 'block' : 'none';
            updateSourceMatchInstructions(); // Update instructions when match type changes
        });
    }

    // Update instructions based on Source Match Mode and Match Type
    function updateSourceMatchInstructions() {
        if (!redirectSrcMatchSelect) return;

        const mode = redirectSrcMatchSelect.value;
        const matchType = matchTypeSelect ? matchTypeSelect.value : 'exact';

        // Always hide pathOnlyTip for non-exact matches
        if (matchType !== 'exact' && pathOnlyTip) {
            pathOnlyTip.style.display = 'none';
        }

        // Check match type and update instructions accordingly
        if (matchType === 'regex') {
            // Regex mode
            if (srcMatchInstructions) {
                if (mode === 'pathonly') {
                    srcMatchInstructions.textContent = '{{ 'Match by path pattern (regex). Works across all domains.'|t('redirect-manager') }}';
                } else {
                    srcMatchInstructions.textContent = '{{ 'Match by full URL pattern (regex) including domain.'|t('redirect-manager') }}';
                }
            }
            if (sourceUrlInstructions) {
                if (mode === 'pathonly') {
                    sourceUrlInstructions.textContent = '{{ 'Enter a regex pattern to match paths (e.g., ^/blog/.* or /category/[^/]+).'|t('redirect-manager') }}';
                } else {
                    sourceUrlInstructions.textContent = '{{ 'Enter a regex pattern to match full URLs (e.g., ^https://example.com/blog/.*).'|t('redirect-manager') }}';
                }
            }
            if (sourceUrlInput) {
                sourceUrlInput.placeholder = mode === 'pathonly' ? '^/blog/.*' : '^https://example.com/blog/.*';
            }
        } else if (matchType === 'wildcard') {
            // Wildcard mode
            if (srcMatchInstructions) {
                if (mode === 'pathonly') {
                    srcMatchInstructions.textContent = '{{ 'Match by path pattern (wildcard). Works across all domains.'|t('redirect-manager') }}';
                } else {
                    srcMatchInstructions.textContent = '{{ 'Match by full URL pattern (wildcard) including domain.'|t('redirect-manager') }}';
                }
            }
            if (sourceUrlInstructions) {
                if (mode === 'pathonly') {
                    sourceUrlInstructions.textContent = '{{ 'Enter a wildcard pattern to match paths. Use * for any characters (e.g., /blog/* or /category/*/posts).'|t('redirect-manager') }}';
                } else {
                    sourceUrlInstructions.textContent = '{{ 'Enter a wildcard pattern to match full URLs. Use * for any characters (e.g., https://example.com/blog/*).'|t('redirect-manager') }}';
                }
            }
            if (sourceUrlInput) {
                sourceUrlInput.placeholder = mode === 'pathonly' ? '/blog/*' : 'https://example.com/blog/*';
            }
        } else if (matchType === 'begins_with' || matchType === 'prefix') {
            // Prefix/Begins With mode
            if (srcMatchInstructions) {
                if (mode === 'pathonly') {
                    srcMatchInstructions.textContent = '{{ 'Match any path starting with the pattern. Works across all domains.'|t('redirect-manager') }}';
                } else {
                    srcMatchInstructions.textContent = '{{ 'Match any URL starting with the pattern including domain.'|t('redirect-manager') }}';
                }
            }
            if (sourceUrlInstructions) {
                if (mode === 'pathonly') {
                    sourceUrlInstructions.textContent = '{{ 'Enter the starting path (e.g., /blog matches /blog, /blog/post, /blog/category).'|t('redirect-manager') }}';
                } else {
                    sourceUrlInstructions.textContent = '{{ 'Enter the starting URL (e.g., https://example.com/blog matches all URLs starting with it).'|t('redirect-manager') }}';
                }
            }
            if (sourceUrlInput) {
                sourceUrlInput.placeholder = mode === 'pathonly' ? '/blog' : 'https://example.com/blog';
            }
        } else if (matchType === 'contains') {
            // Contains mode
            if (srcMatchInstructions) {
                if (mode === 'pathonly') {
                    srcMatchInstructions.textContent = '{{ 'Match any path containing the pattern. Works across all domains.'|t('redirect-manager') }}';
                } else {
                    srcMatchInstructions.textContent = '{{ 'Match any URL containing the pattern including domain.'|t('redirect-manager') }}';
                }
            }
            if (sourceUrlInstructions) {
                if (mode === 'pathonly') {
                    sourceUrlInstructions.textContent = '{{ 'Enter text to match anywhere in the path (e.g., old-post matches /blog/old-post/123).'|t('redirect-manager') }}';
                } else {
                    sourceUrlInstructions.textContent = '{{ 'Enter text to match anywhere in the URL (e.g., old-post matches any URL containing it).'|t('redirect-manager') }}';
                }
            }
            if (sourceUrlInput) {
                sourceUrlInput.placeholder = mode === 'pathonly' ? 'old-post' : 'old-post';
            }
        } else {
            // Exact match mode (default)
            if (mode === 'pathonly') {
                if (pathOnlyTip) pathOnlyTip.style.display = 'block';
                if (srcMatchInstructions) {
                    srcMatchInstructions.textContent = '{{ 'Match by path only (e.g., /old-page). Works across all domains.'|t('redirect-manager') }}';
                }
                if (sourceUrlInstructions) {
                    sourceUrlInstructions.textContent = '{{ 'Enter the path to match (e.g., /old-page). Full URLs will be automatically converted to paths.'|t('redirect-manager') }}';
                }
                if (sourceUrlInput) {
                    sourceUrlInput.placeholder = '/old-page';
                }
            } else {
                if (srcMatchInstructions) {
                    srcMatchInstructions.textContent = '{{ 'Match by complete URL including domain (e.g., https://example.com/old-page).'|t('redirect-manager') }}';
                }
                if (sourceUrlInstructions) {
                    sourceUrlInstructions.textContent = '{{ 'Enter the full URL to match (e.g., https://example.com/old-page).'|t('redirect-manager') }}';
                }
                if (sourceUrlInput) {
                    sourceUrlInput.placeholder = 'https://example.com/old-page';
                }
            }
        }
    }

    // Initialize and watch for changes
    if (redirectSrcMatchSelect) {
        updateSourceMatchInstructions();
        redirectSrcMatchSelect.addEventListener('change', updateSourceMatchInstructions);
    }

    // Auto-complete URL fields on form submit
    $('form').on('submit', function(e) {
        const sourceUrlInput = document.getElementById('sourceUrl');
        const destinationUrlInput = document.getElementById('destinationUrl');
        const srcMatchMode = redirectSrcMatchSelect ? redirectSrcMatchSelect.value : 'pathonly';
        const corrections = [];

        // Function to extract path from URL
        function extractPath(url) {
            try {
                const urlObj = new URL(url.startsWith('http') ? url : 'https://' + url);
                return urlObj.pathname + urlObj.search + urlObj.hash;
            } catch (e) {
                return url;
            }
        }

        // Auto-correct Source URL based on match mode
        if (sourceUrlInput && sourceUrlInput.value) {
            let value = sourceUrlInput.value.trim();

            if (srcMatchMode === 'pathonly') {
                // Path only mode: everything should become a path
                if (value.startsWith('http://') || value.startsWith('https://')) {
                    // Full URL entered - extract just the path
                    const path = extractPath(value);
                    sourceUrlInput.value = path;
                    corrections.push('Source URL: Converted to path → ' + path);
                } else if (!value.startsWith('/') && value.includes('.')) {
                    // Looks like a domain without protocol (e.g., example.com/page)
                    const path = extractPath(value);
                    sourceUrlInput.value = path;
                    corrections.push('Source URL: Converted to path → ' + path);
                } else if (!value.startsWith('/')) {
                    // Plain text without slash - add slash
                    sourceUrlInput.value = '/' + value;
                    corrections.push('Source URL: Added / → /' + value);
                }
            } else {
                // Full URL mode: only auto-correct if it looks like a domain
                if (!value.startsWith('http://') && !value.startsWith('https://') && value.includes('.')) {
                    // Has a dot - looks like a domain, add https://
                    const correctedValue = 'https://' + value;
                    sourceUrlInput.value = correctedValue;
                    corrections.push('Source URL: Added https:// → ' + correctedValue);
                }
                // Otherwise, leave as-is and let server-side validation handle it
            }
        }

        // Auto-correct Destination URL (same logic as shortlink-manager)
        function autoCorrectUrl(input, fieldName) {
            if (!input || !input.value) {
                return;
            }

            let value = input.value.trim();

            // Skip if already valid
            if (value.startsWith('http://') || value.startsWith('https://') || value.startsWith('/')) {
                return;
            }

            // Has dot - looks like a domain, add https://
            if (value.includes('.')) {
                const correctedValue = 'https://' + value;
                input.value = correctedValue;
                corrections.push(fieldName + ': Added https:// → ' + correctedValue);
            } else {
                // No dot - assume it's a path, add /
                const correctedValue = '/' + value;
                input.value = correctedValue;
                corrections.push(fieldName + ': Added / → ' + correctedValue);
            }
        }

        autoCorrectUrl(destinationUrlInput, 'Destination URL');

        // Show notification if any corrections made
        if (corrections.length > 0) {
            Craft.cp.displayNotice(corrections.join('<br>'));
        }
    });

    // Update status code tip
    function updateStatusCodeTip() {
        if (!statusCodeSelect || !statusCodeTipText) return;
        const code = parseInt(statusCodeSelect.value);
        let tip = '';

        switch(code) {
            case 301:
                tip = '<strong>301 - Moved Permanently:</strong> Use when content has permanently moved. Search engines will update their index. <a class="go" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301" target="_blank" rel="noopener">Learn more</a>';
                break;
            case 302:
                tip = '<strong>302 - Found (Temporary):</strong> Use for temporary redirects. Search engines keep the original URL. <a class="go" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/302" target="_blank" rel="noopener">Learn more</a>';
                break;
            case 303:
                tip = '<strong>303 - See Other:</strong> Redirect to a different resource, typically after a form submission. <a class="go" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/303" target="_blank" rel="noopener">Learn more</a>';
                break;
            case 307:
                tip = '<strong>307 - Temporary Redirect:</strong> Like 302 but guarantees the request method won\'t change (POST stays POST). <a class="go" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/307" target="_blank" rel="noopener">Learn more</a>';
                break;
            case 308:
                tip = '<strong>308 - Permanent Redirect:</strong> Like 301 but guarantees the request method won\'t change (POST stays POST). <a class="go" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/308" target="_blank" rel="noopener">Learn more</a>';
                break;
            case 410:
                tip = '<strong>410 - Gone:</strong> Content permanently deleted and won\'t come back. Search engines remove it from index. <a class="go" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/410" target="_blank" rel="noopener">Learn more</a>';
                break;
        }

        statusCodeTipText.innerHTML = tip;
    }

    if (statusCodeSelect) {
        updateStatusCodeTip();
        statusCodeSelect.addEventListener('change', updateStatusCodeTip);
    }
{% endjs %}
